(*| 
============================================================
Кунг-фу-Петух. Введение в Coq, MathComp и MathComp-Analysis.
============================================================

:Автор оригинала karate-coq: Рейнальд Аффельдт (Reynald Affeldt)
:Дата публикации оригинала karate-coq: 13 января 2025 г.
:Автор курса по Coq: Антон Трунов
:Дата публикации оригинала курса по Сoq: 11 марта 2021 г.

:Автор перевода-конспекта и размышлений: Вася
:Дата начала путешествия: 27 октября 2025 г.
:Погода: Дождливая, хуёвая
:Настроение: Заебись

|*)

(*|
.. role:: strike
    :class: strike

.. math::

   \newcommand{\eqdef}{\overset{\mathrm{def}}{=}}
|*)

(*| .. attention:: **Может представлять опасность для разума здорового человека**. |*)

(*|
   Этот текст является *крайне вольным переводом краткой выжимки* памятки курса
   введения в пакет `MathComp-Analysis <https://github.com/math-comp/analysis>`_
   и `курса Антона Трунова
   <https://github.com/anton-trunov/csclub-coq-course-spring-2021>`_.

   **Лайфхак**: если дышать клеем из пакета в метро, то люди будут отсаживаться.

   Я перевожу/пишу/размышляю тут "вслух" по мере самостоятельного прохождения
   этих курсов от нехуй делать без какой-либо цели. Поэтому снимаю с себя любую
   ответственность за качество и достоверность данного конспекта-перевода и тем
   более за его, ебать, "культуру". |*)

(*| Введение
============ |*)

(*| Этот документ — мои конспекты курса по Coq 2021 г от Антона Трунова. С
другой стороны это конспекты, перевод, и размышления на тему памятки, написанной
Рейнальдом Аффельдтом для курса продолжительностью около 10 часов, который
проходил в Высшей школе математики при университете г. Нагоя всего 4 дня в
декабре 2022 г (*прим. перев. - нихуя они умные там, в Японии*). Его цель —
предоставить необходимую базу по Coq и библиотеке MathComp﻿, чтобы можно было
познакомиться с MathComp-Analysis.

А то щас везде ЛЛМ, ИИ, ХУИ. Короче заказал себе натальную карту, параллельно
ещё к психологу хожу, лайфкоучу. Вчера ещё у таролога был. Стартуем. |*)

(*| Глава 1. Краткое представление о Петушаре, Мелкомасштабном отражении и Математических компонентах
===================================================================================================== |*)

(*| Цель этой главы — дать представление о некоторых теорем-пруверах,
построенных на основе теории зависимых типов. |*)

(*|
1.1 Немного истории
------------------- |*)

(*| Феномен появления такой штуки как теорем-прувер является одним из
результатов исследований основ математики, ведущихся с прошлого века. Тема
глубокая, в двух словах не пояснить, но поговаривают, что началось всё с
обнаружения противоречий в *ранней* теории множеств, в которую закралась залупа
под названием `парадокс Рассела
<https://en.wikipedia.org/wiki/Russell%27s_paradox>`_. Ты по-любому про неё
слышал, даже если не знаешь что такое "матёрый". Если нет, то почитай по ссылке
и приходи. Короче, проблема известна:

.. math::

   a \eqdef \{ x | x \notin x \} \Rightarrow a \in a \equiv a \notin a

Теория множеств быстро была исправлена, чтобы избежать таких противоречий. Для
этого нужно просто запретить множеству содержать само себя в качестве своего
элемента. Ну и множество всех множеств тогда тоже придётся запретить.

Идея использовать *типы* это альтернатива теории множеств, чтобы пофиксить её
косяки. `Теория типов <https://en.wikipedia.org/wiki/Type_theory>`_ была
предложена тем же Расселом в 1908 г и была развита в `Principia Mathematica
<https://en.wikipedia.org/wiki/Principia_Mathematica>`_, написанной Уайтхедом и
Расселом в 1910-1913 гг. Суть этого трёхтомника — идея о сводимости математике к
`логике высказываний
<https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0_%D0%B2%D1%8B%D1%81%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9>`_
(пропозициональной логике). Где-то через 20 лет Хаскелл Карри показывает
соответствие между логикой высказываний и `комбинаторной логикой
<https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0>`_.
Ещё через 10 лет, в 1940 г Алонзо Чёрч показывает как `типизировать λ-исчисление
<https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5>`_.
Постепенно становилось ясно, что типы можно использовать для проверки
доказательств и что существует связь с алгоритмами/вычислениями. Это привело к
"открытию" `соответствия Карри-Ховарда
<https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%9A%D0%B0%D1%80%D1%80%D0%B8_%E2%80%94_%D0%A5%D0%BE%D0%B2%D0%B0%D1%80%D0%B4%D0%B0>`_
в 1969 г.

Вроде как, впервые проверка доказательств на компе с использованием теории типов была реализована де Брёйном в 1967–1968 гг. в виде теорем-прувера `Automath <https://en.wikipedia.org/wiki/Automath>`_. Эту его штуку никто не рекламировал и походу никто за пределами универа ей и не пользовался, но толчок к дальнейшим исследованиям она дала. Исследования теории типов и её применения подхватили Мартин-Лёф и Робин Милнер в 1970-х. Эти исследования привели в том числе к созданию `логики для вычислимых функций <https://ru.wikipedia.org/wiki/Logic_for_Computable_Functions>`_ и языка ML. Ну и там были ещё всякие крутые математики причастны, которые не были упомянуты.

Вообще люто угарать по *метаматематике* было модно в первые :math:`\frac{2}{3}` того столетия. Начиная с 1934–1935 годов, `Бурбаки <https://en.wikipedia.org/wiki/Nicolas_Bourbaki>`_ тоже﻿ уделяли внимание понятию математической структуры. Но они использовали теорию множеств, которая, как писал Лео Корри, была там какой-то хуйнёй прилепленной сбоку, навязанной Бурбаки их собственными взглядами на основания математики. А работа над Coq началась во Франции в 1984 г и продолжается до сих пор. |*)

(*| 1.2 Нахуя они вообще нужны, эти теорем-пруверы?
----------------------------------------------------------- |*)

(*| Это вопрос, который обычно задают первым делом. |*)

(*| В основном чтобы:

1. **Формально верифицировать** ПО.
2. **Доказывать** теоремы на компах и **автоматически проверять** неебаца большие доказательства.
|*)

(*| И вообще, доказывать теоремы на бумаге неудобно. Чтобы понять почему,
достаточно бегло посмотреть на иерархию математических структур в MathComp даже
на момент 2023 г и охуеть.

TODO тут должна быть картинка с иерархией этих структур.

Или вот ещё: по версии `Quanta Magazine
<https://www.quantamagazine.org/the-year-in-math-20241216/>`_ главным
достижением в математике за 2024 год стало доказательство гипотезы Ленглендса.
Можете `ознакомиться <https://people.mpim-bonn.mpg.de/gaitsgde/GLC/>`_ с
800-страничным доказательством, разбитым на 5 частей. Я лично рот ебал.

|*)


(*|
::

  Технический довод, приведённый уважаемым автором, который трудно проверить и
  который выглядит похожим на уже известные правильные рассуждения, почти
  никогда не проверяется подробно.

*писал Владимир Воеводский в 2014*
|*)

(*| Получается, что Coq﻿ нужен для верификации компьютерных программ и
математики. Ну и конечно же кок помогает учиться, это же пруф-ассистент. А ещё
он самый хайповый. Не знаю, насколько это правда, но автор пишет, что остальные
системы типа Isabelle/HOL, Lean, итд) тупо не получают такого академического
признания.

Часто упоминают, что помощью Coq были верифицированы:

- Теорема о 4-х красках Теорема о нечётном порядке Теорема Абеля–Раффини
- Компилятор языка C

|*)

(*|
Вот, например, как выглядит формулировка теоремы о 4-х красках в Coq:

.. code-block:: coq

   Theorem four_color (m : map R) : simple_map m -> map_colorable 4 m.

А вот так теорема о нечётном порядке:

.. code-block:: coq

   Theorem Feit_Thompson (gT : finGroupType) (G : {group gT}) :
     odd #|G| -> solvable G.
|*)

(*| Сложна и нихуя не понятно, мне тоже, это нормально. Вроде как дальше должно
стать понятнее. А может и не должно — хуй его знает. Ну и это теоремы из области
теории графов и алгебры, а тут речь пойдёт о мат. анализе, рано или поздно.|*)

(*| А ещё, `вот тут на первых слайдах
<https://anton-trunov.github.io/csclub-coq-course-spring-2021/slides/intro.html>`_
есть более развёрнутый, но краткий ответ на вопрос "зачем нужна формальная
верификация". |*)


(*|
1.3 Это базовый минимум
----------------------- |*)

(*|
::

  Все с чего-то начинали, но ты больше не начинай, брат.
|*)

(*| .. admonition:: Формальное доказательство.

       Это доказательство, в котором каждый
       логический вывод проверен до самых фундаментальных аксиом.

       *Томас К.Х.*
|*)

(*|
Базовые правила формальных доказательств:

- Все промежуточные логические шаги приводятся без единого исключения
- Не делается никаких обращений к интуиции, даже если переход от интуиции к логике является тривиальным
- Формальное доказательство менее интуитивно, но и менее подвержено логическим ошибкам
|*)

(*| Тут щас будет про основы Coq, ssreflect и mathcomp. Мы это всё знаем,
поэтому частично пропустим все объяснения и немного понабираем код, чтобы
привыкнуть к аппарату. |*)

(*| Вот так мы импортируем базовые штуки из mathcomp: |*)

From mathcomp Require Import ssreflect ssrfun ssrbool eqtype. (* .none *)
From mathcomp Require Import ssrnat. (* .none *)

Module My00. 

  Fixpoint add n m :=
    if n is n'.+1
    then (add n' m).+1
    else m.

  Compute add 2 3.
  About add.
  Check add 2.

(*| Эмм. Ну понятно. Лучше пока переключимся на курс Антона, ибо он пизже как
"база".

Кстати, `вот слайды
<https://anton-trunov.github.io/csclub-coq-course-spring-2021/slides/intro.html>`_,
которые можно было полистать вместо чтения этого невменяемого текста, но уже поздно. |*)

End My00.

(*|
1.4 Курс Антона
---------------
|*)

(*| .. admonition:: Требования к подготовке.

       Чтобы было по-кайфу желательно знакомство с основами логики и основами
       ФП. |*)

(*|
Антон рекомендует читать эти 2 книги по ходу дела:

- `Programs and Proofs <https://ilyasergey.net/pnp/>`_: Mechanizing Mathematics with Dependent Types - I. Sergey
- `Mathematical Components book  <https://math-comp.github.io/mcb/>`_ - A. Mahboubi, E. Tassi

Остальное можно найти на `гх вики кока <https://github.com/rocq-prover/rocq/wiki#rocq-books-and-tutorials>`_.
|*)

(*|
1.4.1 Простые типы
------------------
|*)

(*| Сначала нужно импортировать самые базовые штуки из `ssreflect`. |*)

From mathcomp Require Import ssreflect.

(*| Определим новый модуль, чтобы избежать конфликтов имен со стандартной библиотекой. |*)

Module My01.
(*| Чтобы лучше разобраться как разные вещи работают "под капотом", мы делаем
вид, что изначально у нас нет ничего и мы начинаем самостоятельно постепенно
добавлять всякие типы. |*)

(*| Вот так можно определить тип `bool` с двумя конструкторами: `true` и
`false`: |*)
  
  Inductive bool : Type :=
  | true
  | false.

(*|
- `Inductive` — ключевое слово для определения нового типа.
- `Type` — это "тип типов" или "вселенная типов".
|*)

  Check false : bool.
  Check false. (* .unfold *)

(*|
Теперь, когда у нас есть какой-то простейший тип `bool`, мы можем
создавать типы функций с помощью конструктора для типов функций — стрелочки:
|*)

  Check (bool -> bool) : Type.

(*| А чтобы создать саму функцию, можно использовать ключевое слово `fun`. Вот
пример анонимной (:math:`λ`) функции: |*)
  Check (fun b : bool => b). (* .unfold *)

(*| Тип в анонимной функции можно и не писать. Тогда Coq создаст
экзистенциальную переменную `?T`, означающую "некоторый тип `?T`, который можно
вывести из контекста": |*)

  Check fun b => b. (* .unfold *)

(*| .. admonition:: Утверждения типизации.

      `Утверждения типизации
      <https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5#%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D1%8B_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B8_%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8>`_
      вроде :math:`\Gamma \vdash t : T` связывают некоторый контекст :math:`\Gamma`
      (гамма) и два терма :math:`t` и :math:`T`.

      **Контекст** :math:`\Gamma` это такое место,
      где хранятся все известные нам факты и предположения в тот момент, когда нам
      встречается терм, который мы видим справа от :math:`\vdash`. Контекст может быть
      пустым или содержать типизированные переменные и определения:

      **Типизированная переменная** – пара из имени и типа:

      `Variable n : nat`

      **Типизированное определение** – тройка из имени, терма и типа:

      `Definition a : T := t`

|*)


(*| Ну вот выше написано буквально тоже самое, что мы описали только что
словами.

Попробуем применить ф-цию к аргументу типа `bool`. |*)

  Check (fun b => b) true. (* .unfold *)

(*| Опа, `?T` исчезла. Как и ожидалось, Coq вывел тип, используя тип аргумента
(`bool`). |*)

(*| Пример функции высшего порядка и её тип: |*)

  Check fun (f : bool -> bool) => f true. (* .unfold *)

(*| Coq, ясен хуй, умеет вычислять. |*)

  Compute (fun b => b) true. (* .unfold *)
  
(*|
Определения и функции
^^^^^^^^^^^^^^^^^^^^^
|*)
  
(*| Поехали дальше. Можно определять всякие штуки, вот так: |*)
  
  Definition idb := fun b : bool => b.

(*| С этими "определениями" можно делать те же операции, что и с термами: чекать
тип, вычислять и т.д. |*)
  
  Check idb. (* .unfold *)
  Check (fun (f : bool -> bool) => f true) idb. (* .unfold *)
  Compute idb false. (* .unfold *)

(*| Команда `Fail` используется, когда хочется "ожидать ошибку". Пример: |*)

  Fail Check (fun (f : bool -> bool) => f true) false.

(*| Мы применяем функцию высшего порядка к терму типа `bool`, а она хочет тип
`bool -> bool`. Кстати, можно даже писать `Fail Fail...`, чтобы проверить что
"ошибка НЕ произошла (как и ожидалось)". |*)

(*|
Паттерн матчинг. Элиминация. Редукции. Eval
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
|*)
  
(*| Определим функцию отрицания: |*)

  Definition negb :=
    fun (b : bool) =>
      match b with
      | true => false
      | false => true
      end.

  Check negb. (* .unfold *)
  Compute (negb true). (* .unfold *)
  Compute (negb false). (* .unfold *)

(*| Результат `negb true` можно пошагово разложить на последовательность
редукций:

`negb true`

:math:`\rightsquigarrow \delta`

`(fun (b : bool) => match b with | true => false | false => true end) true`

:math:`\rightsquigarrow \beta`

`match true with | true => false | false => true end`

:math:`\rightsquigarrow ι`

`false`

Выше наглядно показано что именно делают эти редукции, а теперь просто скажем
это словами:

- :math:`\delta` (дельта-редукция) — разворачивает определение

- :math:`\beta` (бета-редукция) — подставляет значения аргумента в тело
  определения

- :math:`\iota` (ёпта-редукция) — выполняет паттерн-матчинг

|*)

(*| Можно управлять степенью раскрытия через команду `Eval` — она может
применять разные стратегии редукции. |*)

  Eval cbv delta in negb true. (* .unfold *)
  Eval cbv beta delta in negb true. (* .unfold *)
  Eval cbv beta delta iota in negb true. (* .unfold *)

(*| Порядок тут не важен. |*)

(*|
Символические вычисления / вычисления с переменными
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
|*)
  
(*| В новых версиях Coq `просит
<https://rocq-prover.org/doc/master/refman/language/core/assumptions.html#rocq:warn.Use-of->`_
помещать `Variable` или `Hypothesis` внутрь секий. |*)

  Section MySymbolic.

(*| Теперь можно объявить какую-то переменную. |*)

    Variable c : bool.
    
(*| С переменными можно производить вычисления. Ниже видно как переменная `c`
останавливает цепочку редукций на шаге паттерн матчинга (:math:`\iota` —
ёпта-редукции). |*)
    
    Compute idb c. (* .unfold *)
    Compute negb c. (* .unfold *)

(*| Вот два варианта :math:`\land` для `bool`. |*)

    Definition andb (n m : bool) :=
      match n with
      | false => false
      | true => m
      end.

    Definition andb' (n m : bool) :=
      match m with
      | false => false |
        true => n
      end.

(*| Экстенсионально эти функции равны, в том смысле, что: :math:`\forall b\ c.\
andb\ b\ c = andb'\ b\ c`.

Но если использовать символьный аргумент, то видно, что их поведение чуть
разное, просто потому что `andb` разбирает первый аргумент, ну а `andb'` —
второй. |*)

    Compute andb c true. (* .unfold *)
    Compute andb c false. (* .unfold *)
    
    Compute andb' c true. (* .unfold *)
    Compute andb' c false. (* .unfold *)

(*| .. admonition:: Интенсиональность и Экстенсиональность.

       Функции "равны" **интенсионально**, если они написаны одинаково. Ну типа буква в букву.

       То есть:

       - :math:`f(x) = x + 2` :math:`g(x) = x + 2`

       Функции "равны" **экстенсионально**, если пофиг как они написаны.
       Главное, что для всех аргументов функция :math:`f` выдает тот же
       результат, что и функция :math:`g`.

       Вот, например, две функции, которые равны экстенсионально:

       - :math:`\displaystyle f(x) = x + 2`

       - :math:`\displaystyle g(x) = \frac{x^2 - 4}{x - 2} + 2` для :math:`x \neq 2`

       Таким образом получается, например, что все функции соритировки списка
       экстенсионально равны между собой. Короче, экстенсиональность это когда
       :math:`\forall x: f(x) = y(x)`. Ну и для функций большего количества
       аргументов та же фигня. |*)

(*| Пока закроем эту секцию. |*)

  End MySymbolic.

(*|
Индуктивные типы и рекурсивные функции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
|*)
  

(*| ::

      В какую психушку? Вы чё, угараете?
|*)
  
(*| Определим новый индуктивный тип для `чисел Пеано
<https://ru.wikipedia.org/wiki/%D0%90%D0%BA%D1%81%D0%B8%D0%BE%D0%BC%D1%8B_%D0%9F%D0%B5%D0%B0%D0%BD%D0%BE>`_.
|*)

  Inductive nat : Type :=
  | O
  | S of nat.
  
(*| Напечатем определение. |*)

  Print nat. (* .unfold *)

(*| Проверим тип. |*)

  Check nat. (* .unfold *)

(*| Посмотрим на типы значений. |*)

  Check O. (* .unfold *)
  Check S O. (* .unfold *)
  Check S (S O). (* .unfold *)
  Check S (S (S O)). (* .unfold *)
  
(*| Унарная запись неудобна для вычислений, но суперудобна для доказательств.
Поэтому унарные числа часто встречаются в доказательствах и для них есть
специальная нотация — можно просто писать 0, 1, 2, 3 и так далее вместо вот этих
термов типа `S (S (S O))`. Чтобы можно было просто писать числа, нужно закрыть
наш этот модуль `My01` и тогда будет использоваться стандартное определение
`nat` и станут доступны соответствующие нотации. |*)
  
(*| Определим пару арифметических операций с этими нашими числами. |*)

  Definition succn := S.
  
(*|
Тотальность
^^^^^^^^^^^
|*)

(*| С функцией, которая возвращает предыдущее число немного сложнее, тк хз что
возвращать для `O`.
   
.. code-block:: coq

   Definition predn (n : nat) : nat :=
     match n with
     | S x => x
     | O => _ (* А тут что? *)
     end.

Coq — язык тотальный, то есть хрен там, а не исключение можно кинуть. Нам надо
реально вернуть что-то типа nat. Прикинем вообще, какие есть способы написать
эту функцию:

* `pred : nat -> nat` — просто возвращаем что-то по умолчанию (0 самое логичное,
  чо уж там)

* `pred : nat -> option nat` — возвращаемый тип можно сделать `option`

* `pred : forall n : nat, (n <> 0) -> nat` — потребовать `n <> 0`, чтобы
  гарантировать, что функцию не вызовут с нулём.

На практике используется, как правило, первый вариант.

|*)

  Definition predn (n : nat) : nat :=
    match n with
    | S x => x
    | O => O
    end.

(*| То же самое и с делением — если делим на ноль, просто возвращаем ноль и не
ебём мозги. Казалось бы будто так можно всю логику сломать, но ничего подобного.
Просто местами придётся добавить парочку предусловий в леммы. |*)
  
(*|
Рекурсия
^^^^^^^^
|*)
  
(*| Классика: сложение двух чисел. Это рекурсивная функция, поэтому надо
использовать команду `Fixpoint` вместо `Definition`. |*)

  Fixpoint addn (n m : nat) {struct n} : nat :=
    match n with
    | O => m
    | S n' => S (addn n' m)
    end.

(*| Кусок `{struct n}` указывает по какому параметру идёт рекурсивный вызов —
тут это `n`. Мы как будто подсказываем Coq'у какой терм структурно уменьшается.
Конкретно для `addn` не обязательно было это указывать, так как Coq по умолчанию
предполагает, что это будет первый аргумент. Дальше мы увидим, что бывают случаи
когда это необходимо. |*)

(*| :math:`2 + 2 = 4` |*)
  
  Compute addn (S (S O)) (S (S O)). (* .unfold *)
  
(*| Как это можно записать более идиоматично. |*)

  Fixpoint addn_idiomatic (n m : nat) : nat :=
    if n is S n' then S (addn_idiomatic n' m) else m.

(*| .. admonition:: Fixpoint это сахар.

       Внутри у `Fixpoint` всё тот же `Definition`, а ещё `fix`,
       ну а `fix` это `комбинатор неподвижной точки <https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80_%D0%BD%D0%B5%D0%BF%D0%BE%D0%B4%D0%B2%D0%B8%D0%B6%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BA%D0%B8>`_.

|*)
  
(*| Посмотрим что там внутри. |*)

  Print addn_idiomatic. (* .unfold *)
  
(*| Имя после `fix` используется для рекурсивных вызовов и оно не обязано
совпадать с настоящим именем функции, хоть хуем назови, т.е. можно было бы и
так: |*)

  Definition addn_no_sugar :=
    fix hooy (n m : nat) {struct n} : nat :=
      match n with
      | O => m
      | S n' => S (hooy n' m)
      end.

(*| Определим ещё одну функцию сложения, но в этот раз используем более
идиоматичный синтаксис и сделаем рекурсию по второму аргументу. |*)

  Fixpoint addn' (n m : nat) {struct m} :=
    if m is (S m') then S (addn' n m') else n.

(*| Щас снова будем работать с символьными вычислениями, поэтому нужно делать
это внутри секции. Да, секции можно "переоткрывать". |*)

  Section MySymbolic.

    Variable z : nat.

    Compute addn O z. (* .unfold *)
    Compute addn' O z. (* .unfold *)

  End MySymbolic.

(*| Допустим мы сделали ошибку и ебанули рекурсию не по структурно меньшему
`m'`, а снова по `m`. В таком случае **тоталити чекер** скажет нам "ты чо
творишь ёбаный рот, ты сказал, что шаришь в этой теме". |*)

  Fail Fixpoint addn_loop (n m : nat) {struct n} : nat :=
    if n is S _
    then S (addn_loop n m)
    else m.

(*| Видно, что он прям синтаксис проверяет, чтобы находить такие косяки. |*)

(*|
Взаимная рекурсия
^^^^^^^^^^^^^^^^^
|*)

  Fixpoint is_even (n : nat) : bool :=
    if n is S n' then is_odd n' else true
  with is_odd n :=
    if n is S n' then is_even n' else false.

(*| Обе эти взаимно-рекурсивные функции — `is_even` и `is_odd` — теперь доступны
для использования. |*)

  Compute is_even (S (S (S O))). (* 3 *) (* .unfold *)
  Compute is_even (S (S O)). (* 2 *) (* .unfold *)
  Compute is_odd (S (S (S O))). (* 3 *) (* .unfold *)
  Compute is_odd (S (S O)). (* 2 *) (* .unfold *)

  (*| Закроем наш корневой модуль. |*)

End My01.

(*| Теперь все его определения получат префикс имени модуля. |*)

Check My01.nat. (* .unfold *)
Check My01.addn. (* .unfold *)


(*| Дальше мы забиваем на свои самописные версии и переключаемся на готовые
реализации из MathComp. |*)

From mathcomp Require Import ssrnat ssrbool.

(*| После импорта Coq предупреждает: "некоторые стандартные нотации перекрыты".
Нам вообще похую. Эти ворнинги можно отключить вот так: |*)

Set Warnings "-notation-overridden".

(*| Теперь над доступны функции для работы с `bool` и `nat` из библиотеки
`mathcomp`. |*)

Module My02.

(*| Вот, например, :math:`a \oplus b`. Это операция `XOR` или другими словами
"сложение по модулю 2". |*)

  Print addb. (* .unfold *)

(*| С помощью команды `About` можно узнать чуть больше инфы, чем сообщает
`Check`. |*)

  About nat. (* .unfold *)
  About S. (* .unfold *)

(*| А вот и упомятый выше сахар для натуральных чисел Пеано. |*)

  Check S (S (S O)). (* .unfold *)
  Check 42. (* .unfold *)

(*| Отключение/включение синтаксического сахара. |*)

  Set Printing All. Check 5 + 4. (* .unfold *)
  Unset Printing All.

(*| Как выяснить значения непонятных нотаций. |*)

  Locate ".+1". (* .unfold *)

(*| Хотя, иногда бывает сложно понять, что является частью нотации, а что нет. |*)

  Locate ".+". (* .unfold *)

  Section MySymbolic.

    Variable x : nat.

    Check x.+1. (* .unfold *)

  End MySymbolic.

(*| Короче, **нотации** это просто удобные текстовые сокращения, их можно
свободно менять. А **определения** это фундаментальные объекты в теории: они
влияют на всё. |*)

End My02.

(*|
Практика
^^^^^^^^
|*)

(*| Теперь немного практики — сделаем домашку из курса. Я это уже всё решал лет
5 назад, но всё к забыл. Решу всё ещё разок, заново. |*)

Module My03.

(*| Продолжаем работать с нашими собственными определениями булевых значений и
натуральных чисел. |*)

  Inductive bool :=
  | true
  | false.

  Definition negb :=
    fun (b : bool) =>
      match b with
      | true => false
      | false => true
      end.

(*| **Упражнение 1**: Булевы функции. |*)

(*| **1a**. Определите функцию `orb`, реализующую дизъюнкцию (логическое "или")
для булевых значений, и тщательно протестируйте её при помощи команды `Compute`.
|*)

  Definition orb (b c : bool) : bool :=
    match b, c with
    | false, false => false
    | _, _ => true
    end.

  Compute orb true true.
  Compute orb true false.
  Compute orb false true.
  Compute orb false false.

(*| **1b**. Определите функцию `addb`, реализующую `XOR` (:math:`a \oplus b`).
Попробуйте придумать более одного способа реализации (не просто поменять местами
аргументы) и исследуйте, как ведёт себя редукция функции при наличии
символических переменных. |*)

  Section MySymbolic.

    (*| Для наглядности распишем все кейсы. |*)

    Definition addb0 (b c : bool) : bool :=
      match b, c with
      | true, true => false
      | true, false => true
      | false, true => true
      | false, false => false
      end.

    Variable x : bool.

    Compute addb0 true x. (* .unfold *)
    Compute addb0 x true. (* .unfold *)

    (*| Попробуем теперь использовать анонимные функции. |*)

    Definition addb1 :=
      fun (b : bool) =>
      fun (c : bool ) =>
        match b, c with
        | true, true => false
        | false, false => false
        | _, _ => true
        end.

    Compute addb1 true x. (* .unfold *)
    Compute addb1 x true. (* .unfold *)

(*| Ну символически-вычисленные термы одинаковы. А что будет, если сравнить
цепочки редукций? |*)

    Eval cbv delta in addb0 true x. (* .unfold *)
    Eval cbv delta in addb1 true x. (* .unfold *)

    Eval cbv delta beta in addb0 true x. (* .unfold *)
    Eval cbv delta beta in addb1 true x. (* .unfold *)

    Eval cbv delta beta iota in addb0 true x. (* .unfold *)
    Eval cbv delta beta iota in addb1 true x. (* .unfold *)

(*| Ну очевидно, что оно всё одинаковое. Но пока у нас разница между `addn0` и
`addn1` только в том, используем ли мы анонимные функции или нет. Похоже это
вообще никак не влияет на цепочку редукций и в задаче требовалось проверить
какое-то другое различие.

А что, если добавить какую-нибудь комбинацию :math:`\land`, :math:`\lor` или
:math:`\lnot` в тело функции, но так, чтобы это не повлияло не результат? Ну
типа сделать эти две функции экстенсионально одинаковыми, но интенсионально
различными? |*)

    Definition addb2 (b c : bool) : bool :=
      orb (negb (orb (negb b) c)) (negb (orb b (negb c))).

    Compute addb2 true false.
    Compute addb2 false true.
    Compute addb2 true true.
    Compute addb2 false false.

    Compute addb2 true x.
    Compute addb2 x true.

    (*| Сравним теперь цепочки редукций. |*)

    Eval cbv delta beta in addb0 true x.
    Eval cbv delta beta in addb2 true x.
    Eval cbv delta beta iota in addb0 true x. (* .unfold *)
    Eval cbv delta beta iota in addb2 true x. (* .unfold *)

  End MySymbolic.
  
(*| **1c**. Определите функцию `eqb`, реализующую проверку равенства на булевых
значениях, то есть `eqb b c` должно возвращать `true` тогда и только тогда,
когда `b` и `c` равны. Добавьте юнит-тесты. Под юнит-тестами тут и дальше
имеется ввиду, что надо просто сделать `Compute` и убедиться в корретности
результата. |*)

  Definition eqb (b c : bool) :=
    negb (addb0 b c).

  Compute eqb true false.
  Compute eqb false true.
  Compute eqb true true.
  Compute eqb false false.

(*| **Упражнение 2**: Арифметика. *)

  Inductive nat : Type :=
  | O
  | S of nat.

(*| **2a**. Определите функцию `dec2` типа `nat -> nat`, которая уменьшает
натуральное число на 2. Например, для числа `5` должно вернуться `3`. Напишите
несколько юнит-тестов для `dec2`. Что функция должна возвращать для `1` и `0`?
|*)

(*| Будем `O` возвращать, практичности и удобства ради. |*)

  Definition dec2 (n : nat) :=
    if n is (S (S n')) then n' else O.

  Compute dec2 (S (S (S (S (S O))))). (* .unfold *)
  Compute dec2 (S O). (* .unfold *)
  Compute dec2 O. (* .unfold *)

(*| **2b**. Определите функцию `subn` типа `nat -> nat -> nat`, которая
принимает два натуральных числа `m` и `n` и возвращает результат вычитания `n`
из `m`. Например, `subn 5 3` должно возвращать `2`. Напишите юнит-тесты. |*)

  Fixpoint subn0 (m n : nat) : nat :=
    match m, n with
    | O, _ => O
    | _, O => m
    | S m', S n' => subn0 m' n'
    end.

(*| Или вот более идиоматичное определение вычитания. |*)

  Fixpoint subn1 (m n : nat) {struct m} :=
    if m is S m'
    then
      if n is S n'
      then m' - n'
      else m
    else m
  where "m - n" := (subn1 m n) : nat_scope.

  Compute (S (S (S (S (S O))))) - (S (S (S O))). (* .unfold *)
  Compute (S (S O)) - O. (* .unfold *)
  Compute (S (S (S O))) - (S O). (* .unfold *)
  Compute (S (S (S O))) - (S (S O)). (* .unfold *)
  Compute (S (S (S O))) - (S (S (S O))). (* .unfold *)
  Compute (S O) - (S (S (S O))). (* .unfold *)

(*| **2c**. Определите функцию `muln` типа `nat -> nat -> nat`, которая
принимает два натуральных числа `m` и `n` и возвращает результат их умножения.
Напишите юнит-тесты. |*)

(*| Умножение это как будто сокращённое сложение: :math:`a * 3 ≡ a + a + a`.
Поэтому определим сначала операцию сложения для наших чисел. |*)

  Fixpoint addn (m n : nat) {struct n} : nat :=
    if n is S n'
    then S (addn m n')
    else m
  where "m + n" := (addn m n) : nat_scope.

(*| Проверим, что это вообще работает как мы ожидаем. |*)

  Compute (S (S O)) + (S (S (S O))). (* .unfold *)

  Compute O + (S O). (* .unfold *)

  Compute O + (S (S O)). (* .unfold *)

  Compute (S (S O)) + O. (* .unfold *)

(*| Теперь определим:

:math:`m * n ≡ m + \dots + m`. |*)

  Fixpoint muln (m n : nat) {struct n} : nat :=
    if n is S n'
    then m + (m * n')
    else O
  where "m * n" := (muln m n) : nat_scope.

  Compute (S (S O)) * (S (S (S O))). (* 2 * 3 = 5 *) (* .unfold *)
  Compute O * (S O). (* 0 * 1 = 0 *) (* .unfold *)
  Compute (S O) * (S (S O)). (* 1 * 2 = 2 *) (* .unfold *)
  Compute (S (S O)) * O. (* 2 * 0 = 0 *) (* .unfold *)
  Compute (S (S O)) * (S O). (* 2 * 1 = 2 *) (* .unfold *)

(*| **2d**. Реализуйте функцию сравнения на равенство `eqn` для натуральных
чисел типа `nat -> nat -> bool`. Она должна возвращать `true` тогда и только
тогда, когда числа равны. |*)

  Fixpoint eqn (m n : nat) : bool :=
    match m, n with
    | O, O => true
    | S m', O => false
    | O, S n' => false
    | S m', S n' => m' = n'
    end
  where
    "m = n" := (eqn m n) : nat_scope and
    "m <> n" := (negb (m = n)) : nat_scope.

  Compute (S O) <> O. (* .unfold *)
  Compute (S (S O)) = (S (S O)). (* .unfold *)
  Compute (S (S (S O))) <> (S (S O)). (* .unfold *)
  Compute (S (S (S O))) = (S (S (S O))). (* .unfold *)

(*| **2e**. Реализуйте функцию сравнения "меньше или равно" `leq` для
натуральных чисел типа `nat -> nat -> bool`. Выражение `leq m n` должно
возвращать `true` тогда и только тогда, когда :math:`m ≤ n`. Решение не должно
использовать рекурсию, но можно переиспользовать ранее определённые функции. |*)

  Definition leq (m n : nat) : bool :=
    (n - m) <> O.

  (*| В этот раз ради прикола отдельно определим нотацию :math:`\leq` для
  функции `leq`. |*)

  Notation "m <= n" := (leq m n) : nat_scope.
  
  Compute (S O) <= O.
  Compute (S (S O)) <= (S O).
  Compute (S (S O)) <= (S (S (S O))).
  Compute O <= O.
  Compute (S O) <= (S O).

(*| **Дополнительное**. Реализуйте деление `divn` на этих ваших натуральных
числах и напишите несколько юнит-тестов для него. |*)

(*| Аналогично тому, что умножение это фактически сокращённая запись сложения.
Деление должно как-то получаться из серии вычитаний. |*)

(*| Возьмём, например число :math:`12 : 3 = 4`. Попробуем вычитать из :math:`12`
его делитель :math:`3`, пока оно не обратится в :math:`0`. Cколько раз это можно
сделать?

:math:`12 - 3 - 3 - 3 - 3 = 0`.

Всего :math:`4` раза — это и есть частное. |*)

(*| А тут хуяк и допустим мы забыли чо такое этот минус: `subn0` или `subn1`?
|*)

  Locate "_ - _". (* .unfold *)

(*| О, это `subn1`. Ну короче искать мы умеем. |*)

  Fixpoint divn (m n : nat) : nat :=
    if n is S n'
    then
      if m - n' is S m'
      then S (m' / n)
      else O
    else O
  where "m / n" := (divn m n) : nat_scope.

  Compute (S (S (S (S O)))) / (S (S O)). (* 4 / 2 = 2 *) (* .unfold *)
  Compute (S (S (S O))) / (S (S (S O))). (* 3 / 3 = 1 *) (* .unfold *)
  Compute (S (S (S (S (S (S (S (S O)))))))) / (S (S O)). (* 8 / 2 = 4 *) (* .unfold *)
  Compute (S (S (S (S (S O))))) / (S (S O)). (* 5 / 2 = 2 *) (* .unfold *)
  Compute (S O) / O. (* 1 / 0 = 0 *) (* .unfold *)
  Compute O / O. (* 0 / 0 = 0 *) (* .unfold *)

(*| ::

      У меня 10 тыщ пенсия. Я хуй без соли доедаю.
      Ёлочка мне нравится? Елочка блять мне нравится.

Теперь вспомним что там были за задачки на семинаре.
|*)

End My03.

Module My04.
(*|
Семинар
^^^^^^^^
|*)

(*| **Упражнение 1**: Реализуй функции с указанными типами. |*)

  Definition prodA {A B C : Type} :
    (A * B) * C -> A * (B * C) :=
    fun abc =>
      match abc with
      | ((a, b), c) => (a, (b, c))
      end.

  Compute prodA ((true, 1), 2).

  Definition sumA' {A B C : Type} :
    (A + B) + C -> A + (B + C)
  :=
    fun abc =>
      match abc with
      | inl ab =>
          match ab with
          | inl a => inl a
          | inr b => inr (inl b)
          end
      | inr c => inr (inr c)
      end.

  Compute @sumA' nat bool nat (inl (inr true)).
  Compute @sumA' bool nat bool (inr false).

(*| Другая возможная реализация с ипользованием вложенного паттерн-матчинга -
так даже более идиоматично: |*)

  Definition sumA (A B C : Type) :
    (A + B) + C -> A + (B + C)
  :=
    fun abc =>
      match abc with
      | inl (inl a) => inl a
      | inl (inr b) => inr (inl b)
      | inr c => inr (inr c)
      end.

  Compute sumA nat bool nat (inl (inr true)).
  Compute sumA bool nat bool (inr false).

  Check sumA nat nat bool.
  Compute sumA nat nat bool (inl (inl 1)).

  Definition prod_sumD (A B C : Type) :
    A * (B + C) -> (A * B) + (A * C)
  := fun '(a, bc) =>
      match bc with
      | inl b => inl (a, b)
      | inr c => inr (a, c)
      end.                

  Check prod_sumD bool nat bool.
  Compute prod_sumD bool nat bool (true, inr true). (* .unfold *)
  Check prod_sumD nat bool nat.
  Compute prod_sumD bool bool nat (false, inl false). (* .unfold *)

  Definition sum_prodD (A B C : Type) :
    A + (B * C) -> (A + B) * (A + C)
  := fun a_bc =>
      match a_bc with
      | inl a => (inl a, inl a)
      | inr (b, c) => (inr b, inr c)
      end.

  Compute sum_prodD nat nat bool (inr (5, false)). (* .unfold *)
  Compute sum_prodD bool bool nat (inl true).

  (*| **Упражнение 2**: Композиция функций. |*)

  Definition comp A B C (f : B -> A) (g : C -> B) : C -> A
    := fun x => f (g x).

  Compute comp nat nat nat id (fun x => x * 2) 3.

(*| Введи нотацию, чтобы можно было использовать композицию вот так: :math:`f \circ
g`. Возможно, тебе придётся немного подправить настройку неявных аргументов у
`comp`. |*)

  Arguments comp [A B C] _ _ _.

(*| В `ssrfun` есть уже нотация для композии функций, можно использовать её. |*)

  Locate "_ \o _". (* .unfold *)

(*| Но если б её не было, ты мог бы её определить вот так:

`Notation "f \o g" := (comp f g) (at level 70).`
|*)

  Compute ((fun x => x + 1) \o (fun x => x * 2)) 3. (* .unfold *)

(*| Введём пустой тип. |*)

  Inductive void : Type := .

(*| Из пустоты можно получить всё, но сначала *предъяви пустоту*. |*)

  Definition void_terminal (A : Type) :
    void -> A
  :=
    fun x => match x with end.

(*| Введём тип unit — это тип, у которого ровно одно значение (каноническая
форма). |*)

  Inductive unit : Type := tt.

(*| Дай что угодно и получишь это самое, существующее в 1 экземпляре. |*)

  Definition unit_initial (A : Type) :
    A -> unit
  :=
    fun _ => tt.

  Compute unit_initial nat 1.

(*| Подумай над другими сигнатурами типов, использующими `void`, `unit`, `sum` и `prod`: |*)

(*| 1. `(void + unit) * unit -> unit` |*)

Check (fun _ => tt): (void + unit) * unit -> unit. (* .unfold *)

(*| 2. `void -> void + void` |*)

Check (fun x => inr x): void -> void + void. (* .unfold *)

(*| 3. `void * unit + void -> void * unit` |*)

Check
  (fun vu_or_v =>
     match vu_or_v with
     | inl (v, u) => (v, u)
     | inr v => (v, tt)
     end
  ): void * unit + void -> void * unit. (* .unfold *)
  
End My04.

(*|
1.4.2 Полиморфные функции. Параметризованные типы
-------------------------------------------------
|*)

Module My05.

(*|
Полиморфные функции и зависимые функции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
|*)

(*| Была у нас такая функция:

`Definition id := fun (b : bool) => b.`
|*)

(*| Теперь мы хотим такую же, но только чтобы она работала на всех типах, а не
только на `bool`. То есть нам нужна функция не типа `bool -> bool`, а типа
:math:`\alpha → \alpha`. Функции такого типа называются **параметрически
полиморфными**. Но почему-то следующий код не работает: |*)

  Fail Definition id : A -> A := fun (x : A) => a.

(*| Проблема примера выше в том, что Coq не знает, что такое `A`: она нигде не
определена и не связана. Нам нужно явно это указать. Иными словами, мы щас
попытались использовать параметрический полиморфизм в неявной форме, а Coq
поддерживает его только в *явной форме*. По сути, мы хотим сказать что-то вроде
`id : (A : Type) -> A -> A`. Однако это выражение в Coq не означает то, что мы
имеем в виду.

Правильный синтаксис в Coq таков:

`forall ident : term, term`,

где в нашем случае под `term` следует понимать тип.

Ну короче: |*)

  Definition id :
    forall A : Type, A -> A := fun A : Type => fun x : A => x.
  
(*| Пример использования: |*)
  
  Compute id bool true.
  Compute id nat 42.

(*| Теперь функция получает два аргумента — сначала тип, затем значение. Чтобы
применить `id` к данным вроде `true` или `42`, нужно явно указывать тип. Позже
мы научимся, как обходиться без явного указания типа.

Ну и мы только что познакомились с **зависимыми типами**, потому что по
факту тип результата функции `id` зависит от её первого аргумента. |*)

  Check id bool : bool -> bool.
  Check id nat : nat -> nat.

(*| В теории типов это называется :math:`\pi`-типы ("пи"-типы). Можно попробовать
`почитать в вики про пи-типы
<https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF>`_,
но как по мне, если ты заранее не знаешь о чём речь и не знаком с теорией, то
вкуривание той вики-странички будет напряжно. |*)

(*| Типы в Coq — это такие же термы, как и любые другие. Они являются "объектами
первого класса" (на русском это странно звучит, вообще термин звучит как
"first-class citizen"). Это означает, что в Coq типы можно хранить их в
структурах, передавать и возвращать из функций. |*)

(*| Итак: функция типа `forall x : A,B` называется **зависимо типизированной
функцией** из `A -> B(x)`, где `B(x)` может ссылаться на `x`. Ещё иногда такие
функции называют: **"зависимая функция"**, **"функция с зависимым типом"** — это
синонимы. Ну а `B` называют **семейством типов**, потому что для каждого `x`
существует свой тип `B(x)`. |*)

(*| В Coq нет какого-то особого стрелочного типа `->`. Все функции — зависимо
типизированные, а `->` — это просто нотация. Проверим: |*)

  Locate "->". (* .unfold *)

(*| Петушара показывает, что это тоже зависимая функция, просто в ней параметр не
используется (поэтому подчёркивание). Таким образом, обычный тип `A -> B` —
частный случай зависимого типа. |*)

(*| Coq не запрещает явно именовать параметры, даже если они не используются: |*)

  Definition id' :
    forall A : Type ,  forall x : A ,  A
  :=
      fun A : Type =>    fun x : A => x.


(*| Ну короче, если хочется погрузиться и начать шарить в этой теме, то можно
почитать `Introduction to the Calculus of Inductive Constructions
<https://inria.hal.science/hal-01094195/document>`_, а нам пока хватит и такого
понимания. |*)

(*|
Тип-произведение
^^^^^^^^^^^^^^^^
|*)

(*| `Каррирование
<https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5>`_
позволяет работать с функциями любой арности (любого количества аргументов).
Например, сложение имеет тип `nat -> nat -> nat`, что тоже самое, что и `nat ->
(nat -> nat)`. Но что если функция возвращает несколько результатов, как,
например, при целочисленном делении нужно вернуть частное и остаток? |*)

  Inductive prodn : Type := | pairn of nat & nat.

(*| `pairn of nat & nat` означает, что конструктор `pairn` содержит 2 натуральных числа. |*)

  Print prodn. (* .unfold *)

(*| Это назвается и **тип-произведение**, потому что по смыслу это тоже самое,
что и `прямое (декартово) произведение
<https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5>`_,
только на типах, а не на множествах. |*)

(*| Теперь мы могли бы реализовать, например, деление: `divmod : nat -> nat ->
prodn`, но тут появляется проблема — пришлось бы создавать свой
"тип-произведение" под каждую комбинацию типов: `nat*bool`, `bool*nat`, и т.д. |*)

(*|
Параметризованные индуктивные типы
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
|*)
  
(*| Вместо этого мы можем использовать параметризованный индуктивный тип: |*)

  Inductive prod (A B : Type) : Type := pair of A & B.

(*| Важно понимать, что `prod` это не тип, а **конструктор типа**. Проверим: |*)

  Fail Check prod : Type. (* .unfold *)

(*| Видимо потому, что выговаривать "конструктор типа" каждый раз долго, люди
часто всё равно называют их просто "типами". В общем, чтобы получить именно тип,
нужно применить его к аргументам `A, B`: |*)

  Check prod nat bool : Type. (* .unfold *)

(*| Предлагается ещё помедитировать над этим: |*)

  Check pair. (* .unfold *)
  Check pair nat bool 42 true. (* .unfold *)

(*|
Неявные аргументы
^^^^^^^^^^^^^^^^^
|*) 

(*| Всё время явно указывать типы запаришься. Особенно когда сам Coq прекрасно
может догадаться, что ты имел в виду. Например, он ведь точно знает, что у числа
`42` тип `nat`, а у `true` тип `bool`. Значит, он вполне может вывести это сам.
К счастью петушок умеет выводить их автоматически через **неявные аргументы**.
Давай включим их для `id` и `pair`: |*)

  Arguments id [A] _.
  Arguments pair [A B] _ _.

(*| Строка `Arguments id [A] _.` сообщает коку следующее: параметр типа `A`
теперь будет выводиться автоматически, поэтому нам больше не нужно его указывать
вручную. Для `pair` та же фигня, только Coq тут выведет сразу оба типа — `A` и
`B`. Теперь можно писать так: |*)

  Check id 42.
  Check id true.
  Check pair 42 true.

(*| Кстати, вызов `pair nat bool 42 true` (с явной передачей аргументов типа)
теперь зафейлится — `nat` и `bool` стали неявными, и Coq сам должен их
вычислить. |*)

  Fail Check pair nat bool 42 true : prod nat bool. (* .unfold *)

(*| Это не значит, что мы поменяли сам тип `pair`. Нет, внутри всё осталось как
раньше — Coq просто как бы добавил сверху такой удобный слой, чтобы нам не
приходилось писать много руками. Такой прикол часто используют в ML‑подобных
языках, откуда вдохновлялись видимо разработчики кока.

Если вдруг нужно, наоборот, отключить неявное определение и заставить Coq
требовать все аргументы явно, используется `@`. Это такое "локальное отключение
вывода аргументов". |*)

  Check @pair nat bool 42 true : prod nat bool.

(*| .. admonition:: Собачка.

       Оператор `@` локально отменяет вывод неявных аргументов.
|*)
  
(*| Претти-принтер учитывает, какие аргументы сделаны неявными, и по умолчанию
их не показывает — даже если ты сам их написал руками. Иногда это мешает,
например, когда надо точно понять, что именно Coq подставил под капотом. Чтобы
увидеть всё "как есть", включаем специальный режим: |*)

  Set Printing Implicit.
  Check pair 42 true : prod nat bool. (* .unfold *)
  Unset Printing Implicit.
  
(*| Для сравнения: |*) 
  
  Check pair 42 true : prod nat bool. (* .unfold *)
  
(*| В общем, все команды, начинающиеся с `Set ...`, меняют поведение Coq
глобально. Поэтому, если включил — желательно потом выключить через
соответствующую `Unset ...` команду. |*)
  
(*| Да, каждое новое определение или тип прописывать с `Arguments` вручную
немного напрягает. Чтобы Coq сам решал, какие параметры можно сделать неявными,
есть глобальная команда: |*)

  Set Implicit Arguments.
  
(*| С этого момента и до конца файла (или пока не встретится `Unset Implicit
Arguments`) Coq сам будет пытаться выяснить, какие аргументы можно брать неявно.
Можно сказать, у него включается режим "я шарю в этой теме". |*)

(*|
Нотации
^^^^^^^
|*) 
  
(*| Работать с парами через `prod` и `pair` напрямую неудобно и громоздко. Все
обычно пользуются более привычными обозначениями вроде `A * B` для типа
произведения и `(a, b)` для конкретной пары.

К счастью, Coq позволяет вводить свои собственные нотации — по сути, добавлять
новые правила для парсера прямо "на лету". Вообще система нотаций в Coq довольно
хитрая и многослойная, но сейчас мы глянем только основное. |*)

(*| Вот пример нотации для типа произведения (`prod`). Дальше ниже разберём, что
здесь происходит. |*)

  Notation "A * B" :=
    (prod A B)
    (at level 40, left associativity)
    : type_scope.
  
(*|
Заметь, Coq выдаст предупреждение, что нотация уже
переопределяется — это потому что стандартная библиотека уже содержит аналог.
|*) 
  
(*| А теперь разберём по пунктам, что всё это значит:

- `Notation` говорит Coq, что мы сейчас добавим новую синтаксическую конструкцию

- Определяемая нотация берётся в двойные кавычки (чтобы показать точный вид,
  включая пробелы и символы)

- Идентификаторы вроде `A` и `B` автоматически становятся связанными переменными
  внутри тела после `:=`

- Само тело нотации `(prod A B)` обязательно помещается в скобки — это то, во
  что Coq будет реально разворачивать запись при парсинге

- Далее задаётся грамматическая информация, например уровень приоритета (`at
  level 40`) и ассоциативность (`left associativity`). Чем **level** *ниже*, тем
  *сильнее* нотация "сцепляется" с другими операторами

- После этого указывают область видимости — здесь это `type_scope`, то есть
  нотация будет применяться, когда Coq ожидает тип

- При желании можно ещё добавить правила для pretty-printer'а. В этом примере
  это не показано

Теперь, когда мы напишем `A * B`, петушара сам поймёт, что имеется в виду `prod
A B`. Как только Coq встречает подобную запись, то он добавляет соотвествующее
правило в некоторую свою таблицу грамматических правил. |*) 

(*|
Области нотаций
^^^^^^^^^^^^^^^
|*) 
  
(*| Один и тот же символ можно использовать для разных вещей. В нашем
случае мы уже переиспользовали `*` — теперь это не умножение, а тип
произведения. Но по умолчанию `*` вообще-то означает именно умножение для
натуральных чисел. |*)

  Locate "*". (* .unfold *)

(*| В выводе команды `Locate` можно увидеть, что у символа есть "default
interpretation". Это значит, что если Coq не понимает, в каком смысле ты
используешь `*`, он воспримет его как умножение. Поэтому следующая проверка не
сработает: |*)

  Fail Check nat * bool. (* .unfold *)
  
(*| Нужно подсказать Coq'у, что это не оператор умножения, а тип произведения
двух других типов. Чтобы объяснить Coq, что здесь подразумевается тип
произведения, надо указать "область нотации" — с помощью `%type`: |*)

  Check (nat * bool)%type.

(*| Альтернативный способ сделать тоже самое: |*)

  Check (nat * bool) : Type.
  
(*| В этом случае Coq понимает, что в скобках написан тип, а не терм
(житель/значение типа), и значит `*` — это это нотация не для `Nat.muln`, а для
`prod`. |*)
  
(*| Ещё один способ поменять значение символа по умолчанию — это открыть
соответствующую область - `Open Scope`. В Coq области (scopes) ведут себя как
стек: последняя открытая становится текущей. |*)

  Open Scope type_scope.
  Locate "*". (* .unfold *)

(*| Опа, дефолтная интерпретацию нотации "*" изменилась. |*)

  Check (nat * nat).

(*| Когда открытая область больше не нужна, её можно закрыть —  
это "вытолкнет" её со стека и вернёт старое поведение. |*)

  Close Scope type_scope.
  Locate "*". (* .unfold *)
  Fail Check (nat * nat).
  
(*| Кстати, про `left associativity`, которое мы указали в определении нотации
`A * B`. Это нужно для того, чтобы можно было писать кортежи без дополнительных
скобок. Например, тройку из типов `nat`, `bool` и `nat` можно описать так: |*)
  
  Check ((nat * bool) * nat)%type. (* .unfold *)

(*| Из-за ассоциативности влево можно спокойно опустить скобки. |*)

  Check (nat * bool * nat)%type. (* .unfold *)
  
(*| А если наоборот, получится другой, хоть и изоморфный, тип. |*)

  Check (nat * (bool * nat))%type. (* .unfold *)
  
(*| Раз уж мы завели удобную нотацию для `prod`, сделаем то же самое для `pair`,
чтобы можно было писать `(42, true)` вместо `pair 42 true`. |*)
  
(*| Первая наивная попытка сделать эту нотацию могла бы быть такой: |*)
  
  Notation "( p ; q )" := (pair p q).

  Check (1; false). (* .unfold *)

(*| Кстати, пробелы после открывающей и до закрывающей скобки обязательны. |*)
  
(*| Это работает, но только для пар, а вот так уже не получится:

`Check (1; false; 2).`

А мы ведь хотим писать тройки, четвёрки и т.д. Для этого есть **рекурсивные
нотации**: |*)

  Notation "( p , q , .. , r )" :=
    (pair .. (pair p q) .. r) : core_scope.

(*| Здесь мы указываем `core_scope` для нашей нотации, ибо `pair` в отличии от
`prod` это конструктор значения, а не конструктор типа. |*)

  Check (1, false) : nat * bool.
  Check (1, false, true) : nat * bool * bool.
  Check (1, false, 2, true) : nat * bool * nat * bool. (* .unfold *)
  
(*| Теперь можно, наконец, использовать всё это добро для простых функций с
парами. Например, напишем проекции — `fst` и `snd`. |*)

  Definition fst {A B : Type} : A * B -> A :=
    fun p =>
      match p with
      | (a, _) => a
      end.
  
(*| Пока что будем думать что `{A B : Type}` и `[A B : Type]` - одно и тоже. В
том смысле, что `A` и `B` объявлены как неявные параметры. |*)

(*| Если не очень понятно что именно какая-то нотация развернётся, то можно
попросить петушка вывести полную форму без всяких сокращений: |*)

  Print fst.
  Unset Printing Notations.
  Print fst.
  Set Printing Notations.
  
(*| Теперь пишем вторую проекцию, тут всё то же самое: |*)

  Definition snd {A B : Type} : A * B -> B :=
  fun p =>
    match p with
    | pair _ b => b
    end.
  
(*| В ssreflect есть привычная нотация для этих проекций — её тоже сделаем: |*)
  
  Notation "p .1" := (fst p).
  Notation "p .2" := (snd p).

  Compute (true, 39).1.
  Compute (true, 39).2.

(*| А вот функция, которая меняет местами компоненты пары: |*)

  Definition swap {A B : Type} : A * B -> B * A :=
    fun p =>
      match p with
      | (a, b) => (b, a)
      end.

  Compute swap (false, 40).

(*|
Тип-сумма
^^^^^^^^^
|*)

  Inductive sum (A B : Type) :=
    | inl of A
    | inr of B.

  Notation "A + B" :=
    (sum A B)
    (at level 50, left associativity)
    : type_scope.

(*| Аналогичные типы это:

- `Result.t` в `OCaml`

- `Either` в `Haskell`

Наш этот тип `sum` можно использовать для тех же целей, для которых используются
его аналоги. Например, какой-то парсер может иметь тип: `String -> AST + Error`.
То есть он либо попарсил успешно и вернул `AST`, либо не смог и вернул `Error`. |*) 

(*| ::

      - Это смысл нашей передачи - наваливать кринге.
      - Ты правда веришь, что у меня Лилит в первом доме и я устраиваю кринж?
      - Конечно, моя луна подсвечивает твоё солнце, а это значит, что ты настоящий бунтарь.

А теперь задачки.
|*)
  
End My05.

(*| Нам нужно будет работать со списками, поэтому сразу импортируем `seq`. |*)

From mathcomp Require Import seq.

Module My06.

(*|
Практика: Язык арифметических выражений
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
|*)

(*| Определим простой язык, состоящий из констант и произвольно вложенных
операций сложения, вычитания и умножения. |*)

  Inductive expr : Type :=
  | Const of nat
  | Plus of expr & expr
  | Minus of expr & expr
  | Mult of expr & expr.
  
(*| Затем создадим специальную нотацию для нашего языка. Здесь мы повторно
используем стандартные арифметические обозначения, но только внутри двойных
квадратных скобок. |*)

  Declare Custom Entry expr.

(*| Вот это вот выше означает, что мы объявляем `expr` идентификатором для нотации. |*)

(*| Сообщаем парсеру, что `expr` связан с двойными скобками. Это значит, что
внутри двойных скобок парсер будет использовать нотации, связанные с нашим
`expr`. |*)

  Notation "'[[' e ']]'" :=
    e (e custom expr at level 0).

(*| Делаем так, чтобы числа можно было использовать без обёртки в конструктор
`Const`. |*)

  Notation "x" :=
    (Const x)
      (in custom expr at level 0, x bigint).

  Notation "( x )" :=
    x (in custom expr, x at level 2).

  Notation "x + y" :=
    (Plus x y)
      (in custom expr at level 2, left associativity).

(*| **Упражнение 1**: Определить нотации для вычитания и умножения.

**Подсказки**:

- меньший уровень означает более высокий приоритет
- нотации должны начинаться с `in custom expr` как выше

|*)

  Notation "x - y" :=
    (Minus x y)
      (in custom expr at level 2, left associativity).

  Notation "x * y" :=
    (Mult x y)
      (in custom expr at level 1, left associativity).

(*| Вот как записывается `Plus (Const 0) (Plus (Const 1) (Const 2))`: |*)

  Check [[0 + (1 + 2)]].

(*| А вот так `Plus (Plus (Const 0) (Const 1)) (Const 2)`: |*)

  Check [[(0 + 1) + 2]].

(*| **Упражнение 2**: Убедитесь, что следующие строки парсятся как ожидается.
Какой запрос можно использовать для этого? *)

(*| Можно выключить претти-принтинг нотаций и посмотреть глазами что именно там
скрывается под ними. |*)

  Unset Printing Notations.

  Check [[((0 + 1) + 2) + 3]]. (* .unfold *)
  Check [[0 + (1 + (2 + 3))]]. (* .unfold *)
  Check [[0 + 1 * 2]]. (* .unfold *)

  Set Printing Notations.

(*| `Вот тут
<https://coq.inria.fr/refman/user-extensions/syntax-extensions.html#custom-entries>`_
ещё есть хороший пример работы с нотациями и я мб ниже ещё накину пару своих
чуть более детальных примерчиков (если не забуду). |*)

(*| **Упражнение 3**: Напишите вычислитель для языка выражений, который
определяет семантику. Семантика языка выражений должна совпадать с
соответствующими функциями: `addn`, `subn`, `muln`. |*)

(*| Напишем: |*)

  Fixpoint eval (e : expr) : nat :=
    match e with
    | Const n => n
    | Plus e1 e2 => eval e1 + eval e2
    | Minus e1 e2 => eval e1 - eval e2
    | Mult e1 e2 => eval e1 * eval e2
    end.

(*| Тесты для `eval`. |*)

Check erefl : eval [[ 0 - 4 ]] = 0.
Check erefl : eval [[ 0 + (2 - 1) ]] = 1.
Check erefl : eval [[ (0 + 1) + 2 ]] = 3.
Check erefl : eval [[ 2 + 2 * 2 ]] = 6.
Check erefl : eval [[ (2 + 2) * 2 ]] = 8.

(*| .. admonition:: erefl.

       Мы ещё не обсуждали подробно, что значит `erefl`. Но пока давайте
       просто поверим, что если эти строки выше проходят проверку типов, то равенства верны.
|*)

(*|
Практика: Компиляция арифметических выражений в стековый язык
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
|*)

(*| ::

      Брат, всегда сдавайся, не иди до конца.
|*)
  
(*| Вот "низкоуровневый" `стековый язык
<https://en.wikipedia.org/wiki/Stack-oriented_programming>`_, который может
служить целевым языком для компилятора из языка арифметических выражений выше:
|*)

  Inductive instr :=
  | Push (n : nat)
  | Add
  | Sub
  | Mul.

(*| Программа на этом языке — список инструкций, каждая из которых манипулирует
стеком натуральных чисел. Есть инструкции для помещения констант в стек, а также
для сложения/вычитания/умножения двух верхних элементов стека, снятия их со
стека и помещения результата обратно в стек. |*)
  
(*| Можно определить собственные нотации для операций со стеком, чтобы удобнее
писать тесты. Сделаем их такими милыми кошечками, с ушками: |*)

  Notation " <^ n ^> " :=
    (Push n) (at level 0, n constr).

  Notation "<^+^>" := Add (at level 1).
  Notation "<^-^>" := Sub (at level 1).
  Notation "<^*^>" := Mul (at level 1).

  Check <^5^> : instr.
  Unset Printing Notations.
  Check <^39^>. (* .unfold *)
  Check <^+^>. (* .unfold *)
  Check <^-^>.
  Check <^*^>.
  Set Printing Notations.

(*| Можно определить свой собственный тип для списков, но мы будем использовать
тип `seq` из MathComp, который мы имортировали выше.

Кстати, `seq` — это просто нотация для стандартного типа `list`. |*)
  
  Print seq.  (* .unfold *)
  Print list. (* .unfold *)

(*| ^ Сильно вникать не надо, там дофига чего написано, надо просто посмотреть
на первую строчку.

Можно создавать списки так:

- `[::]`         — нотация для конструктора `nil`
- `x :: xs`      — нотация для конструктора `cons`
- `[:: 1; 2; 3]` — последовательность из трёх элементов 1, 2 и 3

Вот пример:
|*)
  
(*| Ну короче, используя `seq`, определим тип "прога" вот так: |*)

  Definition prog := seq instr.

(*| Пример проги `(5 + 4) * 2 - 9`: |*)

  Check [:: <^5^>; <^4^>; <^+^>; <^2^>; <^*^>; <^9^>; <^-^>] : prog.

(*| А тип "стек" так: |*)

  Definition stack := seq nat.

  Compute [:: 1; 2; 3] ++ [::] : stack. (* .unfold *)

  Locate "++". (* .unfold *)
  Print cat.
    
(*| **Упражнение 4**: Реализовать функцию `run` - интерпретатор нашего стекового
языка. Она принимает программу (список инструкций) и текущий стек, и исполняет
программу пошагово, возвращая итоговый стек. |*)

(*| Я сделаю отдельно функцию "шага", мне так будет проще написать `run`. |*)
  
  Fixpoint step (i : instr) (s : stack) : stack :=
    match i, s with
    | Push x, s' => x :: s'
    | Add, x :: y :: s' => (y + x) :: s'
    | Sub, x :: y :: s' => (y - x) :: s'
    | Mul, x :: y :: s' => (y * x) :: s'
    | _, s' => s'
    end.

(*| Тесты: |*)

  Compute step <^+^> [:: 5; 4].
  Compute step <^+^> (step <^4^> (step <^5^> [::])).

  Compute step <^*^> [:: 9; 2].
  Compute step <^-^> [:: 18; 1].

  Fixpoint run (p : prog) (s : stack) : stack :=
    if p is i :: p'
    then run p' (step i s)
    else s.

(*| Тесты: |*)

  Compute run [:: <^1^>; <^2^>; <^+^>] [::]. (* .unfold *)

  Compute run
    [::
       <^5^>; <^4^>; <^+^>;
       <^2^>; <^*^>;
       <^1^>; <^-^>
    ] [::]. (* .unfold *)

  Check erefl :
    run
      [::
         <^5^>; <^4^>; <^+^>;
         <^2^>; <^*^>;
         <^1^>; <^-^>
      ] [::] = [:: 17].

(*| **Упражнение 5**: Реализовать функцию `compile` - компилятор из
"высокоуровневых" выражений в "низкоуровневые" стековые программы и написать
несколько тестов.

Идеи для тестов:

- Проверить, что `run (compile e) [::] = [:: eval e]`, где `e` — произвольное выражение
- Проверить, что `compile` — инъективная функция

|*) 

  Fixpoint compile (e : expr) : prog :=
    match e with
    | Const x => [:: <^x^>]
    | Plus x y => compile x ++ compile y ++ [:: <^+^>]
    | Minus x y => compile x ++ compile y ++ [:: <^-^>]
    | Mult x y => compile x ++ compile y ++ [:: <^*^>]
    end.

(*| Тесты: |*)

  Unset Printing Notations.
  Check compile [[ (5 + 4) * 2 - 9 ]]. (* .unfold *)
  Set Printing Notations.

(*| То, что надо. |*)

  Check erefl :
    compile [[ (5 + 4) * 2 - 9 ]] =
      [:: <^5^>; <^4^>; <^+^>; <^2^>; <^*^>; <^9^>; <^-^>].

(*| Теперь проверим, что `run (compile e) [::] = [:: eval e]`. |*)

  Check erefl :
    run (compile [[ (5 + 4) * 2 - 9 ]]) [::] =
      [:: eval [[ (5 + 4) * 2 - 9 ]]].
  
(*| Убедимся, что `compile` - инъективная функция. По определению `инъективности
<https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%8A%D0%B5%D0%BA%D1%86%D0%B8%D1%8F_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)>`_
это означает, что нам хочется проверить вот такое свойство :math:`f(x_1) =
f(x_2) \Rightarrow x_1 = x_2`. Хм, опробуем понять что это может значить в нашем
случае для `compile`:

`compile(e1) = compile(e2) => e1 = e2`

Ну, наверное, от нас хотят рассуждения вроде таких:

- `eval(e1) = eval(e2) => e1 = e2`
- `run(is1) = run(is2) => is1 = is2`
- `run(compile(e1)) = run(compile(e2)) => eval(e1) = eval(e2) => e1 = e2`

Фиг знает. |*)

(*| **Упражнение 5**: Реализуйте декомпилятор, преобразующий стековую программу
`prog` обратно в выражение `expr`. |*)
  
(*| *Подсказка*: Возможно, стоит ввести рекурсивный вспомогательный метод
`decompile'` для переиспользования в `decompile`. |*)


(*| Тут задача сводится к преобразованию списка инструкций в дерево выражений.
|*)


  Fixpoint decompile' (p : prog) (s : seq expr) : option (seq expr) :=
    match p with
    | [::] => Some s
    | i :: p' =>
      match i with
      | Push x => decompile' p' (Const x :: s)
      | Add =>
        match s with
        | e2 :: e1 :: es => decompile' p' (Plus e1 e2 :: es)
        | _ => None
        end
      | Sub =>
        match s with
        | e2 :: e1 :: es => decompile' p' (Minus e1 e2 :: es)
        | _ => None
        end
      | Mul =>
        match s with
        | e2 :: e1 :: es => decompile' p' (Mult e1 e2 :: es)
        | _ => None
        end
      end
    end.

  Compute decompile' [:: <^5^>; <^4^>; <^+^>; <^2^>; <^*^>].

  Definition decompile (p : prog) : option expr :=
    match decompile' p [::] with
    | Some [:: e] => Some e
    | _ => None
    end.

  Check erefl :
    decompile [:: <^5^>; <^4^>; <^+^>; <^2^>; <^*^>; <^1^>; <^-^>] =
      Some [[ (5 + 4) * 2 - 1 ]].

End My06.

(*|
1.4.3 Логика, равенство, зависимый паттерн-матчинг
--------------------------------------------------
|*)

Module My07.

End My07.

(*| .. raw:: html

       <link rel="stylesheet" href="css/karate-coq.css">
       <script type="text/javascript" src="js/karate-coq.js"></script>
|*)
